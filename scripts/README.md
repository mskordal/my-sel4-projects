# Scripts for usage and automation

## extract-functions.sh
This script parses a C source file and outputs locally defined functions along
with an id for them separated by space. The main function is guar anteed to get
id 1 while every other function will get id >=2 determined by alphabetical
order. Output is written on the `functions.txt` file. 

**NOTE**: Remove the main function for now from the list. There is the issue
where the page to the HLS IP address is mapped in the main function and the pass
does not do that yet.

example output:
```txt
<func_name_x> 2
<func_name_y> 3
<func_name_z> 4
main 1
```

## pass.sh
This script is used to automate the building and testing procedure for the LLVM
pass. It must be run from the build directory used to build the pass. It can
perform the following actions:
1. Cleans the build directory, builds make files with cmake and creates an IR
   file called app.ll from app.c using clang
2. Compiles the pass with make
3. Injects the pass on the source file app.c using clang and produces app
   executable
4. Injects the pass on the IR file app.ll using opt and produces app executable

For instruction run with -h or open and view instructions in the beginning of
the script.

## sel4-compile.sh
Automates the compilation and build process of sel4. Must run from within the
sel4 build directory. 

**Accepts the following arguments**
1. The relative path to the LLVM pass: Passed by `init-build.sh` to the
   project's `CMakeLists.txt`. The pass is used to instrument the main
   application's source.
2. The relative path to the text file containting the list of functions to be
   profiled. It is used as an input file by the LLVM pass.

**Performs the following steps**
1. Empties build directory.
2. Runs `init-build.sh` located at sel4 root dir with flags for compiling on
   the ZCU102 board and with clang instead of gcc. It also passes ahead the 2
   arguments provided from the script. `init-build.sh` generates the ninja
   build files based on cmake.
3. Runs `ninja` to build the project.

## cg-data-to-csv.sh
Takes an input file generated by `read-bram.tcl` and creates a csv file with
readable call-graph data.

## init-board.tcl
Must be sourced from within `xsct`. Connects to the MpSoC of zcu102. Loads
important files such as `fsbl` and then downloads the sel4 image to the core.
Finally sets target to PSU where we can perform memory reads and writes. Must
be used after loading the hardware to the FPGA.

## init-boardhw.tcl
Similar to `init-board.tcl` but does not download the image to the core. Used
for testing the hardware without an Image using memory reads and writes.

## pass-compile.sh
Automates the compilation and build process of the llvm pass. Must run from
within the sel4 build directory. Performs the following steps:
1. Sets the `LLVM_DIR` variable to llvm-15 binaries.
2. Empties the build directory.
3. Runs cmake with the `LT_LLVM_INSTALL_DIR` flag pointing to `LLVM_DIR` and
   arguments specified.

The first argument after specifying `LLVM_DIR` is mandatory and is the path to
LLVM pass source files and `CMakeLists.txt`. The next 3 arguments are optional
and don't need to be passed in a specific order:
1. -DUSE_CLANG=ON : Pass is built to be used with clang             
2. -DUSE_HLS=ON : Pass is built to communicate with HLS
3. -DDEBUG_COMP_PRINT=ON : Enable debug messages during compilation

## read-bram.tcl
Sourced with `xsct`. Performs a series of reads from BRAM and outputs raw data
of words and its addresses to a txt file passed as the first argument.

## run-profile.sh
Is used to run an application with a hardware design as many times as specified
and output the results to a different file on each execution. Takes one
argument which is how many times to run e.g. `run-profile.sh 5` runs 5 times.
It depends on several other scripts which all need to be in the same directory.
It can be configured at its first lines. One cna specify the path to the
scripts, an output file prefix, how many seconds to wait for execution before
reading results, and the path to the xilinx settings script. The script
performs the following steps:
1. Sources the xilinx settings in order to call xsct and vivado
2. For as many times as specified in the first argument:
   1. Calls `program-dev.tcl` with vivado which loads the hardware tp the FPGA
   2. Calls `init-board.tcl` with xsct which loads bootloaders and the Image
   3. Sleeps specified seconds to ensure BRAM is written in time
   4. Calls `read-bram.tcl` with xsct which reads BRAM and writes to a file
   5. Resets the board by sending signals to a USB-relay
